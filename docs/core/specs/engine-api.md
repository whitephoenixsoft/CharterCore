# ENG-API — Minimal Engine Interface Specification  
Status: FROZEN (v10 – Participant Epoch Lifecycle Clarified)  
Applies to: Engine Core (V1/V2+)  
Scope: Deterministic, storage-agnostic engine interface  

Authority: Subordinate to ENG-DOMAIN, ENG-ERROR, ENG-CORE-PURITY, ENG-REVIEW-RETIRED, ENG-SUPERSESSION, ENG-RECEIPT, ENG-INTEGRITY  

---

# 1. Purpose

ENG-API defines the minimal deterministic interface between a host (CLI or other caller) and the Engine Core.

The Engine:

- Operates exclusively on canonical domain objects  
- Operates on exactly one Area at a time  
- Generates all UUIDv7 identifiers internally  
- Emits structured EvaluationReports for every command  
- Emits audit events separately (append-only)  
- Emits immutable session receipts at structural closure  
- Enforces governance slot invariants at command boundary  
- Enforces participant epoch semantics  
- Never manages storage, indexing, or external orchestration  
- Does not evaluate foreign DAGs  

Legitimacy is created only via explicit session acceptance.

Receipts formalize closure but do not create legitimacy.

Bootstrap occurs through standard AUTHORITY sessions.

There are no special bootstrap APIs.

---

# 2. Global Runtime Rules

## ENG-API-00 — Single-Area Runtime Model

An Engine instance operates on exactly one Area at a time.

It must not:

- Host multiple Areas simultaneously  
- Evaluate legitimacy across Areas  
- Retain legitimacy state across rehydration  

Area switching is exclusively a host responsibility via `rehydrate_engine`.

---

## ENG-API-01 — Deterministic Command Reporting

Every mutating API call must return exactly one EvaluationReport.

Read-only calls return deterministic snapshots.

The Engine must not:

- Throw semantic exceptions  
- Return booleans for legitimacy  
- Encode semantic meaning in narrative strings  

All outcomes must be structured and machine-readable.

---

## ENG-API-02 — UUID Ownership

All identifiers are UUIDv7 generated by the Engine:

- session_id  
- participant_id  
- candidate_id  
- resolution_id  
- evaluation_id  
- vote_id  
- receipt_id  

Callers may reference existing IDs but may not generate them.

IDs are valid only within the currently loaded Area.

---

## ENG-API-03 — No Implicit Legitimacy

No API call may:

- Create legitimacy outside acceptance  
- Supersede resolutions directly  
- Mutate immutable objects  
- Auto-close sessions  
- Bypass governance preconditions  
- Evaluate un-rehydrated domain graphs  
- Reuse participant_id values  

Supersession occurs only as a consequence of successful acceptance.

Receipts never create legitimacy.

---

# 3. Engine Rehydration

## ENG-API-04 — rehydrate_engine

Load a complete domain graph for exactly one Area.

Inputs:

- sessions  
- candidates  
- votes  
- resolutions  
- scopes  
- receipts  
- annotations  

Behavior:

- Replaces any previously loaded Area state  
- Validates single-area consistency  
- Validates supersession graph  
- Validates governance slot exclusivity  
- Validates structural references  
- Validates receipt integrity  
- Derives ACTIVE sets  

Outcome:

- Success → Engine enters normal runtime  
- Fatal structural violation → Engine halts  
- Non-fatal integrity issue (per ENG-INTEGRITY) → Engine enters degraded read-only mode  

The Engine exposes no API to evaluate domain graphs without successful rehydration.

---

# 4. Read-Only Evaluation

## ENG-API-05 — evaluate_session

Inputs:

- session_id  

Properties:

- Pure  
- Idempotent  
- Deterministic  
- Strictly non-mutating  

May be invoked in any session state.

Must not:

- Mutate session state  
- Emit receipts  
- Emit audit events  
- Insert implicit votes  
- Trigger lifecycle transitions  

Returns:

EvaluationReport including:

- session_state  
- session_phase  
- can_accept  
- blocking_reasons  
- governance violations  
- constraint violations  

Repeated calls with identical domain state must produce identical results.

Evaluation is simulation only.

Acceptance is the transaction.

---

# 5. Session Lifecycle Commands

All lifecycle mutation commands:

- Enforce phase invariants  
- Enforce governance invariants  
- Enforce participant epoch invariants  
- Return deterministic EvaluationReport  
- Must not mutate state on invariant failure  

---

## ENG-API-06 — create_session

Inputs:

- session_type (AUTHORITY | SCOPE | REGULAR)  
- participants (initial display_name set, optional)  
- annotations (optional)  

Behavior:

- Generates session_id  
- Generates participant_id for each provided display_name  
- Enforces uniqueness of display_name within the initial set  
- Enforces governance prerequisites per session type  

All participant_id values are newly generated and unique.

Failure → deterministic governance or validation error codes.

---

## ENG-API-07 — pause_session

Transitions:

- ACTIVE → PAUSED  

Must fail if:

- Session terminal  
- BLOCK_PERMANENT  

No participant mutation occurs at pause time.

---

## ENG-API-08 — resume_session

Transitions:

- PAUSED → PRE_STANCE  
- BLOCK_TEMPORARY → PRE_STANCE  

Behavior:

- Terminates all existing participation epochs  
- Clears the participant set  
- Clears all recorded votes  
- Does not preserve any prior participant_id values  
- Does not auto-reconfirm participants  

After resume:

- Participants must be explicitly re-added via add_participant  
- Each re-addition generates a new participant_id  
- No participant_id reuse is permitted  

Resume represents a new participation epoch set within the same Session container.

---

## ENG-API-09 — close_session

Transitions:

- ACTIVE → CLOSED  
- PAUSED → CLOSED  
- BLOCK_PERMANENT → CLOSED  

Emits EXPLORATION receipt.

Terminal state.

---

## ENG-API-10 — add_participant

Inputs:

- session_id  
- display_name  

Behavior:

- Allowed only in PRE_STANCE  
- Generates a new participant_id (UUIDv7)  
- participant_id must be unique within the Session  
- Must fail if display_name already exists in the active participant set  
- Must fail if session not in PRE_STANCE  

The Engine must never:

- Reuse participant_id  
- Merge with prior participation epochs  
- Infer identity continuity  

Each call creates a new participation epoch.

---

## ENG-API-11 — remove_participant

Inputs:

- session_id  
- participant_id  

Behavior:

- Allowed only in PRE_STANCE  
- Terminates the referenced participation epoch  
- Removes participant from active set  
- participant_id becomes permanently invalid for reuse  

Must fail if:

- participant_id not active  
- Session not in PRE_STANCE  

Removal does not delete historical references already frozen in snapshots.

---

## ENG-API-12 — add_candidate  
## ENG-API-13 — remove_candidate  
## ENG-API-14 — record_vote  

All:

- Enforce PRE_STANCE / VOTING constraints  
- Enforce immutability after first stance  
- Enforce BLOCK semantics  
- Reject in degraded mode  
- Validate participant_id existence for vote recording  

Votes must reference active participant_id values.

---

## ENG-API-15 — attempt_acceptance

Inputs:

- session_id  

Behavior:

Performs full validation independent of prior evaluation.

Validation steps:

- Governance preconditions  
- Authority usability  
- Scope usability  
- Structural ACTIVE checks  
- Constraint checks  
- Vote evaluation  

On success:

- Freeze participant epoch snapshot  
- Freeze candidate snapshot  
- Freeze stance snapshot  
- Create Resolution  
- Transition session → ACCEPTED  
- Emit LEGITIMACY receipt  
- Apply supersession effects  

On failure:

- No mutation  
- Deterministic error code  

Acceptance is atomic.

Crash before commit → no resolution and no receipt.

Acceptance is prohibited in degraded mode.

---

# 6. Read-Only Queries

## ENG-API-16 — list_sessions  
## ENG-API-17 — list_resolutions  
## ENG-API-18 — get_session_state  
## ENG-API-19 — get_resolution_state  
## ENG-API-20 — get_session_receipt  
## ENG-API-21 — list_session_receipts  

All read-only.

Deterministic ordering required.

Receipt absence must fail deterministically when explicitly requested.

---

# 7. DAG Export

## ENG-API-22 — export_area_dag

Returns complete deterministic Area DAG:

- sessions  
- resolutions  
- candidates  
- votes  
- scopes  
- receipts  
- annotations  

Must:

- Be read-only  
- Be deterministic  
- Match ENG-DOMAIN schema  
- Be suitable for rehydration  

Fail if structural graph incomplete.

Export permitted in normal and degraded modes.

---

# 8. Degraded Read-Only Mode

## ENG-API-23 — Degraded Mode Semantics

In degraded mode:

- All mutating commands fail with DEGRADED_MODE_ACTIVE  
- attempt_acceptance prohibited  
- Session creation prohibited  
- Governance mutation prohibited  

Permitted:

- evaluate_session  
- read-only queries  
- export_area_dag  

Degraded mode must not:

- Mask structural corruption  
- Allow partial legitimacy compilation  
- Allow new receipts  

---

# 9. Blocking Semantics

Blocking is engine-detected.

Evaluation may report blocking.

Only lifecycle or acceptance operations may change blocking state.

Area-wide BLOCK_PERMANENT enforcement applies during acceptance attempts.

---

# 10. Determinism Guarantees

- Identical inputs → identical EvaluationReports  
- Acceptance independent of prior evaluation  
- No timestamp-based precedence  
- No UUID-time precedence  
- No cross-area influence  
- No implicit behavior  
- No participant_id reuse  
- No silent participant persistence across resume  

---

# 11. Final Guarantees

- Single-Area runtime enforced  
- No foreign DAG evaluation path  
- Governance preconditions enforced at command boundary  
- Supersession only via acceptance  
- Receipts immutable and deterministic  
- Participant epochs strictly enforced  
- Evaluation pure and idempotent  
- Acceptance atomic  
- Degraded mode strictly read-only  
- DAG export deterministic  
- All error responses structured and stable  

---

# Mental Model

The Engine is a deterministic legitimacy compiler.

Evaluation inspects.  
Acceptance commits.  
Supersession evolves governance.  
Participant epochs bound presence in time.  
Receipts freeze closure.  
Rehydration defines the universe.  

Everything explicit.  
Everything deterministic.  
Nothing inferred.  
Nothing auto-repaired.  
Nothing evaluated outside a valid Area runtime.